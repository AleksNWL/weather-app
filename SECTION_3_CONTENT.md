# РАЗДЕЛ 3. РАЗРАБОТКА ДИАГРАММ АРХИТЕКТУРЫ

## 3.1 UML диаграммы компонентов

Диаграммы компонентов в нотации UML (Unified Modeling Language) являются важным инструментом для визуализации архитектуры системы и описания взаимодействия между компонентами. В рамках проекта Weather App разработана детализированная UML диаграмма компонентов, которая отражает структуру системы, основные компоненты и их взаимосвязи.

### 3.1.1 Структура компонентов системы

Архитектура Weather App состоит из следующих основных слоев и компонентов:

**Клиентский слой (Client Layer):**
- **App.tsx** – корневой компонент приложения, управляющий состоянием и роутингом;
- **useTheme** – React Hook для управления темой приложения (темная/светлая);
- **weatherService** – сервис для взаимодействия с GraphQL API через Fetch API;
- **Компоненты UI** – Header, SearchBox, Navigation, Weather, Forecast, Analytics, Footer;
- **Страницы** – WeatherPage, HistoryPage, AnalyticsPage.

**Слой API Gateway:**
- **GraphQL Server (Apollo Server)** – сервер GraphQL, обрабатывающий запросы от клиента;
- **Query Resolvers** – резолверы для обработки GraphQL запросов:
  - Weather Resolver (getWeather, getForecast, searchCities);
  - Analytics Resolver (getCityStats, getCityTrends, getPopularCities, getHistory).

**Слой микросервисов:**
- **Weather Service** – микросервис для получения погодных данных из Open-Meteo API;
- **Analytics Service** – микросервис для обработки и хранения статистики запросов.

**Слой данных:**
- **MongoDB** – база данных для хранения истории запросов и аналитики;
- **Open-Meteo API** – внешний источник метеорологических данных.

### 3.1.2 Взаимодействие компонентов

Взаимодействие между компонентами осуществляется следующим образом:

1. **Клиент → Gateway:** Клиентское приложение отправляет GraphQL запросы через Fetch API к API Gateway на порту 4000.

2. **Gateway → Микросервисы:** API Gateway маршрутизирует запросы к соответствующим микросервисам:
   - Запросы погодных данных направляются к Weather Service (порт 4001);
   - Запросы аналитики направляются к Analytics Service (порт 4002).

3. **Weather Service → Open-Meteo API:** Weather Service выполняет HTTP GET запросы к внешнему API Open-Meteo для получения метеорологических данных.

4. **Analytics Service → MongoDB:** Analytics Service взаимодействует с MongoDB через Mongoose для сохранения и получения данных истории и статистики.

5. **Gateway → Клиент:** Gateway агрегирует данные из микросервисов и возвращает результат клиенту в формате GraphQL.

### 3.1.3 DFD Level 0 - Контекстная диаграмма

Диаграмма потоков данных (DFD) Level 0 представляет собой контекстную диаграмму, которая показывает систему как единый процесс и ее взаимодействие с внешними сущностями (акторами).

**Внешние сущности:**
- **Пользователь (User)** – конечный пользователь приложения, взаимодействующий с системой через веб-браузер;
- **Open-Meteo API** – внешний источник метеорологических данных.

**Основной процесс:**
- **Weather App System** – система Weather App, которая обрабатывает все запросы пользователя и взаимодействует с внешними источниками данных.

**Потоки данных:**

От пользователя к системе:
- **Запрос погоды** (Search weather) – пользователь вводит название города для получения информации о погоде;
- **Просмотр истории** (View history) – пользователь запрашивает историю своих запросов;
- **Запрос аналитики** (Analytics request) – пользователь запрашивает статистику и аналитику.

От системы к пользователю:
- **Данные о погоде** (Weather data) – текущая погода, прогноз, статистика;
- **История запросов** (History data) – список предыдущих запросов;
- **Аналитические данные** (Analytics data) – графики, тренды, популярные города.

От системы к Open-Meteo API:
- **Запрос координат** (Geocoding request) – запрос географических координат по названию города;
- **Запрос погоды** (Weather request) – запрос текущей погоды и прогноза.

От Open-Meteo API к системе:
- **Координаты города** (City coordinates) – широта и долгота города;
- **Метеорологические данные** (Weather data) – температура, влажность, давление, ветер и т.д.

Контекстная диаграмма демонстрирует, что система Weather App является посредником между пользователем и внешним источником данных (Open-Meteo API), обрабатывая запросы пользователя и предоставляя ему структурированную информацию о погоде.

### 3.1.4 DFD Level 1 - Детализация основных процессов

Диаграмма DFD Level 1 детализирует основной процесс системы, разбивая его на подпроцессы и показывая потоки данных между ними.

**Основные процессы:**

**1.0 Валидация входных данных (VALIDATE INPUT)**
- **Вход:** название города от пользователя;
- **Процесс:** проверка на пустоту, определение языка (русский/английский), транслитерация кириллицы в латиницу;
- **Выход:** валидный запрос города или сообщение об ошибке.

**2.0 Получение данных о погоде (FETCH WEATHER DATA)**
- **Вход:** валидное название города;
- **Процесс:** параллельное выполнение запросов:
  - getWeather(city) – текущая погода;
  - getForecast(city) – прогноз на 5 дней;
  - getCityStats(city) – статистика города;
  - getCityTrends(city) – тренды температуры;
- **Выход:** объекты с данными о погоде или сообщение об ошибке.

**3.0 Обработка и отображение погоды (PROCESS & DISPLAY WEATHER)**
- **Вход:** данные о погоде, прогнозе, статистике;
- **Процесс:** форматирование температур, преобразование WMO кодов в иконки, парсинг дат, применение CSS стилей;
- **Выход:** отрендеренный пользовательский интерфейс с данными о погоде.

**4.0 Сохранение в историю (SAVE TO HISTORY)**
- **Вход:** данные о погоде;
- **Процесс:** создание объекта HistoryEntry, валидация данных, отправка POST запроса к Analytics Service;
- **Выход:** ID сохраненной записи.

**5.0 Обновление аналитики (UPDATE ANALYTICS)**
- **Вход:** запись истории;
- **Процесс:** вставка в MongoDB, обновление статистики города, расчет трендов, обновление списка популярных городов;
- **Выход:** обновленная база данных.

**6.0 Получение страницы истории (FETCH HISTORY PAGE)**
- **Вход:** параметры пагинации (page, limit);
- **Процесс:** запрос к MongoDB, сортировка по дате (DESC), применение пагинации;
- **Выход:** массив записей истории.

**7.0 Отображение истории (DISPLAY HISTORY)**
- **Вход:** записи истории;
- **Процесс:** маппинг записей в элементы списка, форматирование дат, отображение таблицы/сетки;
- **Выход:** отрендеренный HTML с историей запросов.

**Хранилища данных:**
- **D1: Кэш клиента (Client Cache)** – localStorage для кэширования данных с TTL 5 минут;
- **D2: MongoDB (Weather History)** – база данных для хранения истории запросов и статистики.

Диаграмма DFD Level 1 показывает детальный процесс обработки запросов пользователя, начиная с валидации входных данных и заканчивая отображением результатов, а также процесс сохранения данных в историю и обновления аналитики.

---

## 3.2 Диаграммы потоков данных (DFD)

Диаграммы потоков данных (Data Flow Diagrams, DFD) являются важным инструментом для моделирования потоков информации в системе. DFD показывают, как данные перемещаются между процессами, хранилищами данных и внешними сущностями.

### 3.2.1 Назначение DFD в проекте

В рамках проекта Weather App диаграммы потоков данных используются для:

- **Визуализации потоков данных** – демонстрации того, как данные о погоде перемещаются от внешнего API через микросервисы к клиентскому приложению;
- **Документирования процессов** – описания основных процессов обработки запросов пользователя;
- **Анализа архитектуры** – выявления узких мест и оптимизации потоков данных;
- **Коммуникации с заинтересованными сторонами** – наглядного представления работы системы для разработчиков и администраторов.

### 3.2.2 Уровни детализации DFD

В проекте разработаны два уровня DFD:

**DFD Level 0 (Контекстная диаграмма)** – показывает систему как единый процесс и ее взаимодействие с внешними сущностями (пользователь, Open-Meteo API). Данная диаграмма предоставляет общее представление о системе и ее границах.

**DFD Level 1 (Детализация основных процессов)** – разбивает систему на основные подпроцессы (валидация, получение данных, обработка, сохранение в историю, обновление аналитики) и показывает потоки данных между ними. Данная диаграмма предоставляет детальное представление о внутренней работе системы.

### 3.2.3 Элементы DFD в проекте

**Процессы:**
- Процессы обозначаются округлыми прямоугольниками и представляют функции системы, которые преобразуют входные данные в выходные.

**Потоки данных:**
- Потоки данных обозначаются стрелками и показывают направление движения данных между процессами, хранилищами и внешними сущностями.

**Хранилища данных:**
- Хранилища данных обозначаются открытыми прямоугольниками и представляют места хранения данных (MongoDB, localStorage).

**Внешние сущности:**
- Внешние сущности обозначаются прямоугольниками и представляют акторов, взаимодействующих с системой (пользователь, Open-Meteo API).

### 3.2.4 Описание основных потоков данных

**Поток запроса погоды:**
1. Пользователь вводит название города → Процесс валидации;
2. Валидированный запрос → Процесс получения данных о погоде;
3. Запрос к Open-Meteo API → Получение метеорологических данных;
4. Данные о погоде → Процесс обработки и отображения;
5. Обработанные данные → Отображение пользователю;
6. Данные о погоде → Процесс сохранения в историю;
7. Запись истории → Процесс обновления аналитики;
8. Обновленные данные → Хранилище MongoDB.

**Поток запроса истории:**
1. Пользователь запрашивает историю → Процесс получения страницы истории;
2. Запрос к MongoDB → Получение записей истории;
3. Записи истории → Процесс отображения истории;
4. Отформатированные данные → Отображение пользователю.

**Поток кэширования:**
1. Запрос данных → Проверка кэша (localStorage);
2. Если данные в кэше валидны → Возврат из кэша;
3. Если данных нет в кэше → Запрос к API;
4. Полученные данные → Сохранение в кэш с TTL 5 минут.

Диаграммы потоков данных обеспечивают наглядное представление архитектуры системы и помогают понять, как данные обрабатываются и перемещаются между компонентами.

---

## 3.3 ER-диаграмма модели данных

ER-диаграмма (Entity-Relationship Diagram) представляет собой модель данных, которая описывает структуру базы данных, сущности, их атрибуты и связи между ними. В проекте Weather App используется документная база данных MongoDB, поэтому ER-диаграмма описывает структуру коллекций и документов.

### 3.3.1 Основная сущность: WeatherHistory

Основной сущностью в базе данных является коллекция **WeatherHistory**, которая хранит историю запросов пользователей о погоде. Каждый документ в коллекции представляет собой запись о запросе погоды для конкретного города в определенный момент времени.

### 3.3.2 Структура документа WeatherHistory

**Идентификатор:**
- **_id: ObjectId** – уникальный идентификатор документа (первичный ключ), автоматически генерируется MongoDB.

**Базовая информация:**
- **city: String** – название города, для которого был выполнен запрос (индексируется);
- **country: String** – название страны, в которой находится город;
- **originalQuery: String** – исходный запрос пользователя (может быть на русском языке);
- **queryLanguage: String** – язык запроса ("ru" или "en").

**Метеорологические данные:**
- **temperature: Number** – температура воздуха в градусах Цельсия;
- **feels_like: Number** – ощущаемая температура;
- **temp_min: Number** – минимальная температура;
- **temp_max: Number** – максимальная температура;
- **humidity: Number** – относительная влажность (0-100%);
- **pressure: Number** – атмосферное давление в гектопаскалях (hPa);
- **wind_speed: Number** – скорость ветра в метрах в секунду;
- **wind_deg: Number** – направление ветра в градусах (0-360°);
- **description: String** – текстовое описание погодных условий;
- **icon: String** – код иконки погоды;
- **weathercode: Number** – код погоды по классификации WMO (World Meteorological Organization).

**Геолокация:**
- **coordinates: Object (Embedded)** – вложенный объект, содержащий:
  - **lat: Number** – широта города;
  - **lon: Number** – долгота города.

**Метаданные:**
- **date: Date** – дата и время запроса (индексируется, по умолчанию текущая дата);
- **source: String** – источник данных (по умолчанию "city").

### 3.3.3 Индексы базы данных

Для оптимизации запросов к базе данных созданы следующие индексы:

**1. Составной индекс {city: 1, date: -1}**
- Назначение: быстрый поиск истории запросов для конкретного города, отсортированной по дате (от новых к старым);
- Использование: запросы статистики по городу, получение истории для конкретного города.

**2. Индекс {date: -1}**
- Назначение: быстрый поиск последних запросов, отсортированных по дате;
- Использование: получение общей истории запросов, пагинация истории.

**3. Геопространственный индекс {coordinates.lat: 1, coordinates.lon: 1}**
- Назначение: поиск запросов по географическим координатам;
- Использование: поиск истории для определенной локации, анализ данных по региону.

**4. Индекс {city: 1}**
- Назначение: быстрый поиск всех запросов для конкретного города;
- Использование: статистика по городу, подсчет популярности городов.

### 3.3.4 Пример документа

```json
{
  "_id": ObjectId("6754a3b2c1f2e3d4e5f6g7h8"),
  "city": "Moscow",
  "country": "Russia",
  "originalQuery": "Москва",
  "queryLanguage": "ru",
  "temperature": 5.2,
  "feels_like": 2.1,
  "temp_min": 3.8,
  "temp_max": 6.5,
  "humidity": 85,
  "pressure": 1013,
  "wind_speed": 4.2,
  "wind_deg": 250,
  "description": "Cloudy",
  "icon": "02d.png",
  "weathercode": 2,
  "coordinates": {
    "lat": 55.7558,
    "lon": 37.6173
  },
  "date": ISODate("2024-12-04T10:30:00Z"),
  "source": "city"
}
```

### 3.3.5 Связи и зависимости

В текущей версии проекта база данных содержит одну основную коллекцию **WeatherHistory**. В будущем возможно добавление дополнительных коллекций:

- **city_stats** – агрегированная статистика по городам (средние температуры, количество запросов);
- **popular_cities** – кэш популярных городов для быстрого доступа;
- **trends** – предварительно рассчитанные тренды температуры для оптимизации запросов.

ER-диаграмма модели данных обеспечивает четкое понимание структуры базы данных и помогает разработчикам правильно проектировать запросы и индексы для оптимальной производительности.

---

## 3.4 GraphQL Schema Definition Language (SDL)

GraphQL Schema Definition Language (SDL) является стандартным способом описания структуры GraphQL API. SDL определяет типы данных, запросы (queries), мутации (mutations) и подписки (subscriptions), которые доступны клиентам через GraphQL API.

### 3.4.1 Назначение GraphQL Schema

В проекте Weather App GraphQL Schema определяет:

- **Типы данных** – структуру данных, которые возвращаются клиенту (Weather, Forecast, CityStats и т.д.);
- **Запросы (Queries)** – операции чтения данных, которые может выполнить клиент;
- **Валидацию** – правила валидации входных параметров и типов данных;
- **Документацию** – самодокументирующееся API, которое можно просмотреть в GraphQL Playground.

### 3.4.2 Основные типы данных

**Coordinates:**
```graphql
type Coordinates {
  lat: Float
  lon: Float
}
```
Тип для представления географических координат (широта и долгота).

**Weather:**
```graphql
type Weather {
  city: String
  originalQuery: String
  foundCity: String
  country: String
  temperature: Float
  feels_like: Float
  temp_min: Float
  temp_max: Float
  humidity: Int
  pressure: Int
  wind_speed: Float
  wind_deg: Int
  description: String
  icon: String
  weathercode: Int
  coordinates: Coordinates
}
```
Тип для представления текущих погодных условий для города.

**Forecast:**
```graphql
type Forecast {
  city: String
  country: String
  forecast: [ForecastDay]
}

type ForecastDay {
  date: String
  avgTemp: String
  minTemp: String
  maxTemp: String
  avgHumidity: Int
  mostCommonDescription: String
  icon: String
  weathercode: Int
}
```
Тип для представления прогноза погоды на 5 дней.

**CityStats:**
```graphql
type CityStats {
  avgTemp: Float
  maxTemp: Float
  minTemp: Float
  avgHumidity: Float
  totalRequests: Int
  mostCommonDescription: String
}
```
Тип для представления статистики по городу за определенный период.

**TrendData:**
```graphql
type TrendData {
  date: String
  avgTemp: Float
  maxTemp: Float
  minTemp: Float
}
```
Тип для представления трендов температуры по датам.

**PopularCity:**
```graphql
type PopularCity {
  city: String
  requests: Int
  country: String
}
```
Тип для представления популярного города с количеством запросов.

**HistoryResponse:**
```graphql
type HistoryResponse {
  data: [HistoryEntry]
  pagination: Pagination
}

type HistoryEntry {
  city: String
  temperature: Float
  description: String
  date: String
}

type Pagination {
  page: Int
  limit: Int
  total: Int
  pages: Int
}
```
Тип для представления истории запросов с пагинацией.

### 3.4.3 Запросы (Queries)

**Запросы погодных данных:**
```graphql
type Query {
  """Get current weather for a city"""
  getWeather(city: String!): Weather

  """Get current weather for a city (Russian input support)"""
  getWeatherRU(city: String!): Weather

  """Get 5-day forecast for a city"""
  getForecast(city: String!): Forecast

  """Search cities by name or coordinates"""
  searchCities(query: String!): [CitySearchResult!]

  """Get city coordinates"""
  getCityCoordinates(city: String!): Coordinates

  """Get weather by coordinates"""
  getWeatherByCoords(lat: Float!, lon: Float!): Weather
}
```

**Запросы аналитики:**
```graphql
type Query {
  """Get city statistics (average, max, min over period)"""
  getCityStats(city: String!, days: Int): CityStats

  """Get temperature trends for a city"""
  getCityTrends(city: String!, days: Int): [TrendData!]

  """Get most popular searched cities"""
  getPopularCities(limit: Int): [PopularCity!]

  """Get search history with pagination"""
  getHistory(page: Int, limit: Int): HistoryResponse!
}
```

### 3.4.4 Особенности реализации

**Обязательные параметры:**
- Параметры, помеченные восклицательным знаком (!), являются обязательными (например, `city: String!`).

**Опциональные параметры:**
- Параметры без восклицательного знака являются опциональными (например, `days: Int`).

**Списки:**
- Квадратные скобки обозначают массивы (например, `[CitySearchResult!]` – массив обязательных объектов CitySearchResult).

**Комментарии:**
- Комментарии в тройных кавычках (""") используются для документации запросов и типов, они отображаются в GraphQL Playground.

### 3.4.5 Примеры запросов

**Запрос текущей погоды:**
```graphql
query {
  getWeather(city: "Moscow") {
    city
    temperature
    humidity
    description
    coordinates {
      lat
      lon
    }
  }
}
```

**Запрос прогноза:**
```graphql
query {
  getForecast(city: "London") {
    city
    country
    forecast {
      date
      minTemp
      maxTemp
      mostCommonDescription
    }
  }
}
```

**Запрос статистики:**
```graphql
query {
  getCityStats(city: "Paris", days: 30) {
    avgTemp
    maxTemp
    minTemp
    totalRequests
  }
}
```

**Запрос истории с пагинацией:**
```graphql
query {
  getHistory(page: 1, limit: 20) {
    data {
      city
      temperature
      date
    }
    pagination {
      page
      total
      pages
    }
  }
}
```

### 3.4.6 Преимущества GraphQL Schema

**Типобезопасность:**
- SDL обеспечивает строгую типизацию данных, что помогает избежать ошибок на этапе разработки.

**Самодокументирование:**
- Schema служит документацией API, которую можно просмотреть в GraphQL Playground.

**Гибкость запросов:**
- Клиент может запрашивать только необходимые поля, что оптимизирует передачу данных.

**Валидация:**
- GraphQL автоматически валидирует запросы на соответствие Schema перед выполнением.

GraphQL Schema Definition Language обеспечивает четкое определение структуры API и способствует созданию надежного и эффективного интерфейса взаимодействия между клиентом и сервером.

---

## ПРИМЕЧАНИЯ К ФОРМАТИРОВАНИЮ

1. **Рисунки** должны быть оформлены согласно ГОСТ 2.105-95:
   - Рисунок 3.1 – UML диаграмма компонентов;
   - Рисунок 3.2 – DFD Level 0 (Контекстная диаграмма);
   - Рисунок 3.3 – DFD Level 1 (Детализация основных процессов);
   - Рисунок 3.4 – ER-диаграмма модели данных;
   - Рисунок 3.5 – GraphQL Schema (визуализация).

2. **Таблицы** (если будут добавлены) нумеруются как Таблица 3.1, Таблица 3.2 и т.д.

3. **Ссылки на источники** оформляются в квадратных скобках [1], [2].

4. **Код** (GraphQL SDL, примеры запросов) должен быть оформлен в блоки кода с указанием языка.

---

## ИСТОЧНИКИ ДЛЯ РАЗДЕЛА 3

- DOCUMENTATION.md, раздел 7 (Архитектурные диаграммы)
- gateway/src/config/schema.js – GraphQL Schema Definition
- analytics-service/src/models/WeatherHistory.js – MongoDB модель данных
- Документация по UML, DFD, ER-диаграммам
- Документация по GraphQL Schema Definition Language

