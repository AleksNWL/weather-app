# РАЗДЕЛ 4. ПАТТЕРНЫ ПРОЕКТИРОВАНИЯ

## 4.1 Архитектурные паттерны

Архитектурные паттерны представляют собой проверенные решения для организации структуры приложения и взаимодействия между его компонентами. В проекте Weather App применяются несколько ключевых архитектурных паттернов, которые обеспечивают масштабируемость, производительность и поддерживаемость системы.

### 4.1.1 API Gateway Pattern

API Gateway Pattern представляет собой паттерн проектирования, при котором создается единая точка входа для всех клиентских запросов к микросервисам. Gateway принимает запросы от клиентов, маршрутизирует их к соответствующим сервисам и агрегирует результаты.

**Принципы работы:**

В проекте Weather App API Gateway реализован на основе GraphQL и Apollo Server. Gateway принимает GraphQL запросы от клиентского приложения, определяет, какие данные необходимы, и направляет запросы к соответствующим микросервисам (Weather Service или Analytics Service). Gateway также выполняет валидацию запросов, обработку ошибок и трансформацию данных.

**Реализация в проекте:**

API Gateway реализован в директории `gateway/` и включает следующие компоненты:

- **GraphQL Schema** (`gateway/src/config/schema.js`) – определяет типы данных и запросы, доступные клиентам;
- **Resolvers** (`gateway/src/resolvers/query.js`) – функции, которые обрабатывают GraphQL запросы и направляют их к соответствующим микросервисам;
- **Service Clients** (`gateway/src/services/serviceClients.js`) – клиенты для взаимодействия с микросервисами через REST API;
- **Error Handler** (`gateway/src/middleware/errorHandler.js`) – централизованная обработка ошибок.

**Преимущества использования:**

- **Единая точка входа** – клиенты взаимодействуют только с Gateway, что упрощает интеграцию и скрывает внутреннюю структуру микросервисов;
- **Централизованная логика** – общая логика (валидация, обработка ошибок, трансформация данных) находится в одном месте;
- **Гибкость запросов** – GraphQL позволяет клиентам запрашивать только необходимые данные, что оптимизирует объем передаваемой информации;
- **Агрегация данных** – Gateway может объединять данные из нескольких микросервисов в одном запросе;
- **Абстракция микросервисов** – изменения во внутренней структуре микросервисов не влияют на клиентов.

**Пример использования:**

Клиент отправляет GraphQL запрос для получения погоды и статистики:

```graphql
query {
  getWeather(city: "Moscow") {
    temperature
    humidity
    description
  }
  getCityStats(city: "Moscow", days: 30) {
    avgTemp
    totalRequests
  }
}
```

Gateway обрабатывает этот запрос, направляя запрос погоды к Weather Service, а запрос статистики – к Analytics Service, затем объединяет результаты и возвращает клиенту.

### 4.1.2 Microservices Pattern

Microservices Pattern представляет собой архитектурный подход, при котором приложение разбивается на множество небольших, независимых сервисов, каждый из которых отвечает за определенную бизнес-функцию.

**Принципы работы:**

В проекте Weather App микросервисная архитектура реализована через разделение функциональности на два основных сервиса:

- **Weather Service** (`weather-service/`) – отвечает за получение погодных данных из Open-Meteo API, поиск городов и геокодирование;
- **Analytics Service** (`analytics-service/`) – отвечает за хранение истории запросов, вычисление статистики и анализ данных.

Каждый сервис является независимым приложением, развертывается отдельно и имеет свой порт (Weather Service – 4001, Analytics Service – 4002).

**Реализация в проекте:**

**Weather Service** включает:
- REST API endpoints для получения погоды, прогноза и поиска городов;
- Интеграцию с Open-Meteo API;
- Утилиты для транслитерации русских названий городов;
- Обработку и трансформацию данных из внешнего API.

**Analytics Service** включает:
- REST API endpoints для работы с историей и статистикой;
- Модели данных MongoDB (WeatherHistory);
- Сервисы для вычисления статистики и трендов;
- Агрегацию данных для популярных городов.

**Преимущества использования:**

- **Независимое масштабирование** – каждый сервис может масштабироваться независимо в зависимости от нагрузки;
- **Независимая разработка** – сервисы могут разрабатываться и развертываться независимо;
- **Изоляция отказов** – отказ одного сервиса не приводит к полному отказу системы;
- **Технологическая гибкость** – разные сервисы могут использовать разные технологии (хотя в проекте используется единый стек);
- **Четкое разделение ответственности** – каждый сервис имеет четко определенную область ответственности.

**Взаимодействие сервисов:**

Сервисы взаимодействуют друг с другом через REST API. Weather Service может отправлять данные о запросах в Analytics Service для сохранения в истории. Gateway координирует взаимодействие между сервисами, направляя запросы от клиентов к соответствующим сервисам.

### 4.1.3 MVC (Model-View-Controller) Pattern

MVC (Model-View-Controller) Pattern представляет собой архитектурный паттерн, который разделяет приложение на три основных компонента: Model (модель данных), View (представление) и Controller (контроллер).

**Принципы работы:**

В проекте Weather App паттерн MVC реализован как на клиентской, так и на серверной стороне:

**На клиентской стороне (React приложение):**

- **Model (Модель)** – представляет данные и бизнес-логику:
  - `client/src/services/weatherService.ts` – сервис для работы с API и получения данных;
  - `client/src/types/index.ts` – TypeScript интерфейсы и типы данных (WeatherData, ForecastDay, HistoryEntry и т.д.);
  - `client/src/utils/cache.ts` – утилита для кэширования данных;

- **View (Представление)** – отвечает за отображение данных пользователю:
  - `client/src/components/` – UI компоненты (Weather, Forecast, Analytics, Header, Footer и т.д.);
  - `client/src/pages/` – страницы приложения (WeatherPage, HistoryPage, AnalyticsPage);

- **Controller (Контроллер)** – управляет взаимодействием между Model и View:
  - `client/src/App.tsx` – главный компонент, управляющий состоянием приложения и координацией компонентов;
  - `client/src/hooks/useTheme.ts` – кастомный хук для управления темой приложения;
  - Обработчики событий в компонентах.

**На серверной стороне:**

- **Model (Модель)** – модели данных базы данных:
  - `analytics-service/src/models/WeatherHistory.js` – модель MongoDB для истории запросов;

- **View (Представление)** – представление данных через API:
  - REST API endpoints в сервисах;
  - GraphQL resolvers в Gateway;

- **Controller (Контроллер)** – обработка запросов и бизнес-логика:
  - `gateway/src/resolvers/query.js` – GraphQL resolvers (контроллеры запросов);
  - `weather-service/src/routes/` – Express маршруты (REST контроллеры);
  - `analytics-service/src/routes/` – Express маршруты (REST контроллеры);
  - `analytics-service/src/services/analyticsService.js` – бизнес-логика для аналитики.

**Преимущества использования:**

- **Разделение ответственности** – четкое разделение между данными, представлением и логикой управления;
- **Переиспользуемость** – компоненты View могут использоваться с разными данными Model;
- **Простота тестирования** – каждый компонент может тестироваться независимо;
- **Простота поддержки** – изменения в одном компоненте не влияют на другие;
- **Соответствие принципам React** – паттерн MVC естественно ложится на архитектуру React приложений.

**Пример взаимодействия:**

1. Пользователь вводит название города в компоненте SearchBox (View);
2. Событие обрабатывается в App.tsx (Controller);
3. Controller вызывает weatherService.fetchWeather() (Model);
4. Model получает данные из API и возвращает их в Controller;
5. Controller обновляет состояние приложения;
6. View (Weather компонент) перерисовывается с новыми данными.

### 4.1.4 Cache-Aside Pattern

Cache-Aside Pattern (также известный как Lazy Loading) представляет собой паттерн кэширования, при котором приложение проверяет кэш перед запросом к источнику данных, и если данных нет в кэше или они устарели, загружает их из источника и сохраняет в кэш.

**Принципы работы:**

В проекте Weather App Cache-Aside Pattern реализован на клиентской стороне с использованием localStorage. При запросе данных приложение сначала проверяет наличие данных в кэше, их валидность (на основе времени жизни TTL), и только при отсутствии или истечении срока действия данных выполняет запрос к API.

**Реализация в проекте:**

Кэширование реализовано в `client/src/utils/cache.ts` и включает следующие функции:

- **getCache<T>(key: string)** – получение данных из кэша, если они валидны (не истек TTL);
- **setCache<T>(key: string, data: T, ttl: number)** – сохранение данных в кэш с указанным временем жизни (TTL);
- **removeCache(key: string)** – удаление конкретной записи из кэша;
- **clearExpiredCache()** – очистка всех устаревших записей;
- **getCacheStats()** – получение статистики кэша (общее количество, валидные, устаревшие).

**Интеграция в сервисы:**

Кэширование интегрировано в `client/src/services/weatherService.ts` для следующих типов данных:

- Текущая погода (`weather_{city}`) – TTL 5 минут;
- Прогноз на 5 дней (`forecast_{city}`) – TTL 5 минут;
- Статистика города (`stats_{city}_{days}`) – TTL 5 минут;
- Тренды температуры (`trends_{city}_{days}`) – TTL 5 минут.

**Алгоритм работы:**

1. При запросе данных проверяется наличие ключа в localStorage;
2. Если ключ существует, проверяется валидность данных (сравнение текущего времени с временем создания + TTL);
3. Если данные валидны, они возвращаются из кэша без запроса к API;
4. Если данных нет или они устарели, выполняется запрос к API;
5. Полученные данные сохраняются в кэш с текущим временем и TTL;
6. Данные возвращаются клиенту.

**Преимущества использования:**

- **Уменьшение нагрузки на API** – повторные запросы не требуют обращения к серверу;
- **Улучшение производительности** – мгновенный отклик для данных из кэша;
- **Снижение сетевого трафика** – уменьшение количества HTTP запросов;
- **Персистентность** – данные сохраняются между перезагрузками страницы благодаря localStorage;
- **Автоматическая очистка** – устаревшие данные автоматически удаляются при проверке.

**Ограничения:**

- **Размер localStorage** – ограничение ~5-10 MB в зависимости от браузера;
- **Синхронный API** – localStorage работает синхронно, что может блокировать UI при больших объемах данных;
- **Фиксированный TTL** – одинаковое время жизни для всех типов данных (5 минут).

### 4.1.5 Event-Driven Analytics

Event-Driven Analytics представляет собой паттерн, при котором аналитические данные собираются асинхронно, не блокируя основной поток выполнения приложения. События о действиях пользователей регистрируются и обрабатываются в фоновом режиме.

**Принципы работы:**

В проекте Weather App Event-Driven Analytics реализован через асинхронную отправку данных о запросах погоды в Analytics Service. Когда пользователь запрашивает информацию о погоде, данные о запросе отправляются в Analytics Service для сохранения в истории и обновления статистики, но это не блокирует отображение погодных данных пользователю.

**Реализация в проекте:**

Аналитика реализована следующим образом:

1. **Weather Service** получает запрос о погоде и обрабатывает его;
2. После успешного получения данных о погоде, Weather Service асинхронно отправляет POST запрос в Analytics Service для сохранения записи в истории;
3. **Analytics Service** сохраняет данные в MongoDB и обновляет статистику (популярные города, счетчики запросов);
4. Основной поток выполнения не блокируется, пользователь получает данные о погоде немедленно.

**Преимущества использования:**

- **Неблокирующая обработка** – аналитика не влияет на время ответа основного запроса;
- **Асинхронность** – обработка аналитических данных происходит в фоновом режиме;
- **Масштабируемость** – аналитика может обрабатываться отдельными инстансами Analytics Service;
- **Отказоустойчивость** – отказ Analytics Service не влияет на основную функциональность получения погоды;
- **Гибкость** – легко добавить дополнительную аналитику без изменения основной логики.

**Будущие улучшения:**

В будущем планируется реализация полноценной event-driven архитектуры с использованием message queue (например, RabbitMQ или Apache Kafka) для более надежной доставки событий и возможности обработки больших объемов аналитических данных.

---

## 4.2 Анализ применимости паттернов к проекту

Для обоснования выбора архитектурных паттернов проведен анализ их применимости к проекту Weather App с учетом требований, ограничений и целей разработки.

### 4.2.1 Применимость API Gateway Pattern

**Обоснование применимости:**

API Gateway Pattern является оптимальным решением для проекта Weather App по следующим причинам:

- **Единая точка входа** упрощает интеграцию клиентского приложения, которое взаимодействует только с Gateway через GraphQL, не зная о внутренней структуре микросервисов;
- **Централизованная логика** (валидация, обработка ошибок) упрощает поддержку и развитие системы;
- **GraphQL API** обеспечивает гибкость запросов и оптимизацию объема передаваемых данных;
- **Агрегация данных** позволяет объединять данные из Weather Service и Analytics Service в одном запросе, что улучшает производительность.

**Соответствие требованиям проекта:**

- ✅ Обеспечивает простоту интеграции для клиентского приложения;
- ✅ Поддерживает масштабируемость за счет независимой работы микросервисов;
- ✅ Соответствует ограничениям команды разработки (простота управления);
- ✅ Совместим с выбранными технологиями (GraphQL, Apollo Server, Express.js).

### 4.2.2 Применимость Microservices Pattern

**Обоснование применимости:**

Microservices Pattern хорошо подходит для проекта Weather App:

- **Независимое масштабирование** позволяет масштабировать Weather Service и Analytics Service независимо в зависимости от нагрузки;
- **Разделение ответственности** четко разделяет функциональность получения погодных данных и аналитики;
- **Изоляция отказов** обеспечивает, что отказ Analytics Service не влияет на получение погодных данных;
- **Технологическая гибкость** позволяет в будущем использовать разные технологии для разных сервисов.

**Соответствие требованиям проекта:**

- ✅ Обеспечивает высокую масштабируемость (критерий NFR2);
- ✅ Поддерживает отказоустойчивость (критерий NFR3);
- ✅ Соответствует ограничениям команды (простота развертывания через Docker/Kubernetes);
- ✅ Совместим с выбранными технологиями (Node.js, Express.js, MongoDB).

### 4.2.3 Применимость MVC Pattern

**Обоснование применимости:**

MVC Pattern естественно применяется в React приложениях и обеспечивает:

- **Четкое разделение ответственности** между данными (Model), представлением (View) и логикой управления (Controller);
- **Переиспользуемость компонентов** – компоненты View могут использоваться с разными данными;
- **Простота тестирования** – каждый компонент может тестироваться независимо;
- **Соответствие принципам React** – паттерн MVC органично вписывается в архитектуру React приложений.

**Соответствие требованиям проекта:**

- ✅ Обеспечивает простоту разработки и поддержки (критерий NFR);
- ✅ Улучшает качество кода и его поддерживаемость;
- ✅ Соответствует требованиям задания (MVC указан в исходных данных);
- ✅ Совместим с React и TypeScript.

### 4.2.4 Применимость Cache-Aside Pattern

**Обоснование применимости:**

Cache-Aside Pattern критически важен для проекта Weather App:

- **Уменьшение нагрузки на Open-Meteo API** – бесплатная версия API имеет лимит ~10,000 запросов в день, кэширование позволяет значительно уменьшить количество запросов;
- **Улучшение производительности** – мгновенный отклик для повторных запросов улучшает пользовательский опыт;
- **Снижение сетевого трафика** – уменьшение количества HTTP запросов;
- **Персистентность данных** – localStorage обеспечивает сохранение данных между перезагрузками страницы.

**Соответствие требованиям проекта:**

- ✅ Обеспечивает выполнение требований производительности (NFR1: время ответа < 2 сек);
- ✅ Помогает соблюдать ограничения Open-Meteo API (бесплатная версия);
- ✅ Улучшает пользовательский опыт;
- ✅ Реализуется на клиентской стороне без дополнительных серверных ресурсов.

### 4.2.5 Применимость Event-Driven Analytics

**Обоснование применимости:**

Event-Driven Analytics подходит для проекта Weather App:

- **Неблокирующая обработка** – аналитика не влияет на время ответа основного запроса о погоде;
- **Асинхронность** – обработка аналитических данных происходит в фоновом режиме;
- **Масштабируемость** – аналитика может обрабатываться отдельными инстансами Analytics Service;
- **Отказоустойчивость** – отказ Analytics Service не влияет на основную функциональность.

**Соответствие требованиям проекта:**

- ✅ Обеспечивает выполнение требований производительности (не блокирует основной запрос);
- ✅ Поддерживает масштабируемость аналитики;
- ✅ Обеспечивает отказоустойчивость системы;
- ✅ Соответствует ограничениям проекта (простота реализации).

### 4.2.6 Сводная таблица применимости паттернов

**Таблица 4.1 – Анализ применимости архитектурных паттернов**

| Паттерн | Применимость | Критерии соответствия | Преимущества для проекта |
|---------|--------------|----------------------|-------------------------|
| API Gateway | Высокая | ✅ Простота интеграции<br>✅ Масштабируемость<br>✅ Совместимость с технологиями | Единая точка входа, централизованная логика |
| Microservices | Высокая | ✅ Масштабируемость<br>✅ Отказоустойчивость<br>✅ Простота развертывания | Независимое масштабирование, изоляция отказов |
| MVC | Высокая | ✅ Простота разработки<br>✅ Соответствие заданию<br>✅ Совместимость с React | Четкое разделение ответственности |
| Cache-Aside | Критическая | ✅ Производительность<br>✅ Ограничения API<br>✅ UX качество | Уменьшение нагрузки, улучшение производительности |
| Event-Driven Analytics | Высокая | ✅ Производительность<br>✅ Масштабируемость<br>✅ Отказоустойчивость | Неблокирующая обработка аналитики |

### 4.2.7 Выводы по применимости паттернов

Все рассмотренные архитектурные паттерны являются применимыми и необходимыми для проекта Weather App:

1. **API Gateway Pattern** обеспечивает единую точку входа и упрощает интеграцию клиентского приложения с микросервисами.

2. **Microservices Pattern** обеспечивает масштабируемость и отказоустойчивость системы, что критически важно для веб-приложения.

3. **MVC Pattern** обеспечивает четкую организацию кода и соответствует требованиям задания, а также естественно применяется в React приложениях.

4. **Cache-Aside Pattern** является критически важным для соблюдения ограничений бесплатного API Open-Meteo и обеспечения требуемой производительности.

5. **Event-Driven Analytics** обеспечивает неблокирующую обработку аналитических данных, что улучшает производительность основной функциональности.

Комбинация данных паттернов обеспечивает оптимальный баланс между производительностью, масштабируемостью, простотой разработки и соответствием ограничениям проекта.

---

## ПРИМЕЧАНИЯ К ФОРМАТИРОВАНИЮ

1. **Таблица 4.1** должна быть оформлена согласно ГОСТ 2.105-95
2. **Примеры кода** должны быть оформлены с использованием моноширинного шрифта
3. **Ссылки на источники** оформляются в квадратных скобках [1], [2]
4. **Рисунки** (если будут добавлены) нумеруются как Рисунок 4.1, Рисунок 4.2 и т.д.

---

## ИСТОЧНИКИ ДЛЯ РАЗДЕЛА 4

- DOCUMENTATION.md, раздел 5 (Паттерны проектирования)
- Код приложения:
  - gateway/src/ (API Gateway реализация)
  - weather-service/src/ (Microservices реализация)
  - analytics-service/src/ (Microservices реализация)
  - client/src/ (MVC и Cache-Aside реализация)
- Дополнительная литература по паттернам проектирования

